[notation: ‘=‘ universal, ‘+’ service viewer, ‘*’ M+M]

= use selected inclusion of ODEnableLogging/ODLogging, ODDisableLogging/ODLogging to bracket code that needs to be logged

+ use ‘yarp clean —timeout 3’ logic for port exploration or send the ‘clean’ command to yarp before scanning

+ note that selecting an entity after connecting other entities sometimes causes the new entity to jump!

+ when copying OGDF files into /usr/local/*, use ‘cp -rp’ so that permissions will allow reading!

+ load/save positions, by entity name [optional???]

* change signal handling to use platform-neutral mechanisms

* ‘normal’ services can, of course, have secondary inputs and outputs - ’non-normal’ services respond to ‘restartStreams’, ‘startStreams’ and ‘stopStreams’ requests

* random number stream service; output protocol is ‘d+’

* recorder service; input protocol is ‘i+’

* truncate filter service; input protocol is ‘d+’, output protocol is ‘i+’

* ‘configure’ request for I/O streams, with package argument - filter [no effect], recorder [path to file], ‘random’ [burst size, period]

+ viewer should display service kind, second line on port for ‘protocol = …’ if protocol non-blank

+ viewer should only allow connections where [s.protocol = d.protocol OR d.protocol = ‘’]

* client auto-launch of service, if at all possible - add match criteria of ‘path’, check for ‘path: */EXECUTABLE’, allow multiple matches [to accommodate I/O]; if no match, launch executable, delay, recheck. If match proceed with normal selection criteria. SHOULD NOT DO THIS FOR THE REGISTRY!

* I/O services need unique channel names, service names (but not canonical names) which the companion client has to know; if there is a way to launch executables, then the client should ALWAYS launch an I/O service, giving it the root name to be used
