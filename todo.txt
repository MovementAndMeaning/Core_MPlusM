[notation: ‘=‘ universal, ‘+’ service viewer, ‘*’ M+M]

= use selected inclusion of ODEnableLogging/ODLogging, ODDisableLogging/ODLogging to bracket code that needs to be logged

+ use ‘yarp clean —timeout 3’ logic for port exploration or send the ‘clean’ command to yarp before scanning

+ when copying OGDF files into /usr/local/* from _release, use ‘cp -rp’ so that permissions will allow reading!
[_release/libOGDF.a goes to /usr/local/lib, ogdf/* goes to /usr/local/include]; note that the linker has some issues with OGDF

+ load/save positions, by entity name [optional???]

* change signal handling to use platform-neutral mechanisms

+ put connections on a separate layer, as distinct objects; layer should be above the existing one and have the same dimensions - this way, rendering is automatic and searching entities in the existing layer won’t ‘see’ the connections; each connector knows it’s start / end entities [or their names?] => initially just draw straight lines

Notes from Johnty:

- in terms of having a background thread communicate with the GUI elements, here's the basic outline i followed:

- - i inherited from ChangeListener and had the thread class inherit from ChangeBroadcaster. 

- - then i made a callback for in the GUI class to force an draw update (repaint) on the GUI elements, and triggered a change in the thread class when an event occurs

-- finally, add the GUI class as a listener to the thread using addChangeListener()

- - in terms of synchronisation, i used a basic non-reentrant lock for synchronisation of the shared memory access between the thread and the gui. 

