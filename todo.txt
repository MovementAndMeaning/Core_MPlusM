[notation: ‘=‘ universal, ‘+’ channel manager, ‘*’ M+M, ‘@‘ manual]

= use selected inclusion of ODEnableLogging/ODLogging, ODDisableLogging/ODLogging to bracket code that needs to be logged

* change signal handling to use platform-neutral mechanisms

+ on dragging, do an adjustSize() without repaint?

+ if a connection is made outside of the viewer / manager, make sure that a repaint is triggered, not just for a new entity

* ‘touchShare’ protocol with iOS devices?

* Python, Lua, Tcl (, Common Lisp?) services

* integrate Arduino sensors via Linux-based Arduino boards? SmartTag via TouchShare?

* Tunnel Service and Client need to be bidirectional (use nonblocking I/O?)

- check if the SpiderMonkey library can be statically linked on Windows and if this resolves the exit issue; if so, check if it can be statically linked on OS X

= to determine whether a Windows executable is 32-bit or 64-bit, do “c:\Program Files (x86)\Microsoft Visual Studio 12.0\vc\bin\dumpbin.exe /headers the-program-file.exe”

@ add appendix about setting up Hamachi for use with M+M

+ configuration file should have ‘enabled’, ‘name’, ‘arguments’, where ‘enabled’ is 0 if disabled, non-0 if enabled, ‘name’ is the executable name, et cetera - tab-separated

+ ‘load’ a configuration brings up the configuration editor, with a ‘start’ button, ‘edit’ a configuration, ‘save’ a configuration

@ DOCUMENT the new dialog boxes! Appendix - What happens when YARP is not running

* change ‘-a’ / ‘-auto’ to ‘-g’ / ‘-go’ for services; note that it won’t be necessary for Channel Manager to check for ‘a’, as all adapters are ‘automatic’ as long as their associated service is active, and all services will provide the necessary argument formats to determine when they can be run

* add ‘-a’ / ‘-args’ to adapters and services - returns the arguments format —>
	<argsFormat> ::= <argFormat> | <argFormat> ‘\t’ <argsFormat>
	<argFormat> ::= <typeTagAndInfo> ‘:’ <default value> ‘:’ <text description for label>
	<typeTagAndInfo> ::= <integerTagAndInfo> | <doubleTagAndInfo> | <stringTagAndInfo> | <fileTagAndInfo> | <channelTagAndInfo>
	<integerTagAndInfo> ::= ‘i’ <intRange> | ‘I’ <intRange> # uppercase is required, lowercase is optional
	<intRange> ::= ‘r’ <low value> ‘:’ <high value> | # if value is not present, not constrained
	<doubleTagAndInfo> ::= ‘d’ <dblRange> | ‘D’ <dblRange>
	<dblRange> ::= ‘r’ <low value> ‘:’ <high value> |
	<stringTagAndInfo> ::= ’s’
	<fileTagAndInfo> ::= ‘f’ <fileDirection> | ‘F’ <fileDirection>
	<fileDirection> ::= ‘i’ | ‘o’
	<channelTagAndInfo> ::= ‘c’ | ‘C’
	<default value> ::= <delimiter> <text> <delimiter> # use matching pairs of |, <>, (), {}, [], whichever is not present in the text
—> this can be handled by a new set of classes, in Channel Manager, used to validate a text string (coming from Channel Manager) against the particular argFormat; the text description is used for the dialog label; the argsFormat data should be passed to the ‘processZZZ’ routine, and returned by the ‘-a’ / ‘—args’ option, where it will be used by Channel Manager to construct the dialog box and to validate the entered data

—> all required arguments _must_ appear before all the optional arguments - ignore an executable that doesn’t obey this - and an executable that has only optional arguments can be launched immediately; only optional values should have default values
