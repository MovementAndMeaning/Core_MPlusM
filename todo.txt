[notation: ‘=‘ universal, ‘+’ service viewer, ‘*’ M+M]

= use selected inclusion of ODEnableLogging/ODLogging, ODDisableLogging/ODLogging to bracket code that needs to be logged

+ use ‘yarp clean —timeout 3’ logic for port exploration or send the ‘clean’ command to yarp before scanning

+ when copying OGDF files into /usr/local/*, use ‘cp -rp’ so that permissions will allow reading!

+ load/save positions, by entity name [optional???]

* change signal handling to use platform-neutral mechanisms

+ explore JUCE, SDL (or Processing) as an alternative platform for the viewer

+ ofPoint -> Point<>; set containers visible, but don’t add them to panel - render them during paint

Notes from Johnty:

- in terms of having a background thread communicate with the GUI elements, here's the basic outline i followed:

- - i inherited from ChangeListener and had the thread class inherit from ChangeBroadcaster. 

- - then i made a callback for in the GUI class to force an draw update (repaint) on the GUI elements, and triggered a change in the thread class when an event occurs

-- finally, add the GUI class as a listener to the thread using addChangeListener()

- - in terms of synchronisation, i used a basic non-reentrant lock for synchronisation of the shared memory access between the thread and the gui. 

